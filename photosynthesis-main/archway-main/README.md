![image](https://i.imgur.com/Os2PnLF.jpg)

# Photosynthesis


Photosynthesis meaning of term in Dapps context is how Dapps gain energy.
Currently revenue source of Dapps in Archway is gas fee share and minting share.
This revenue generated can be staked on liquidity chains like stride, quicksilver, pstake.
In return Dapp gets liquidity tokens, also participate in automatic restaking by paying commission to stride, quicksilver, pstake on each consecutive restake.
On the other hand, Dapp can avail all benefits of liquidity tokens like lending and other applications. Using Archway and Stride/Quicksilver Cli middleware can be created for liquid staking of Dapp rewards generated by archway. As rewards are periodic, their liquid staking will also be periodic. 

How will the dapp generate revenue
++++++++++++++++++++++++++++++++++ 

Dapp will generate revenue by liquid staking Archway rewards and using benefits of restaking/autocompounding staking (this acts as sort of probiotic bacteria, increasing staking rewards automatically)  rewards offered by liquidity protocols, by using applications of liquid archway rewards tokens, participating in airdrop revenue offered by liquidity protocols, using epoch middleware to maximise liquid staking strategy by staking maximum threshold rewards, saving gas fees, claiming at maximum yield redemption rate.
Now, the main bullet point is how will archway generate revenue.
Archway chain will generate revenue by taking certain fee from cumulative redemption amount of liquid tokens of Dapps.


Advantage of epoch architecture
+++++++++++++++++++++++++++++++

1)enableliquidstaking - to enable liquid staking for contract, 

2rewards_withdrawal - Contracts/Dapp  will automatically be able to withdraw rewards from pool in periodic way

3)minimumrewardstoliquidstake - Dapps or contracts will be able to accumulate rewards and stake threshold reward amount periodically

4)Archway will be able to centrally liquid stake rewards of all Contracts/Dapps saving lot of gas fees.

5)Dapps will be able to autocompound their liquid stake via liquidity providers.

6)Dapps will be able to increase their liquidity via lending or LPing.

7)Dapps/contracts will be able to redeem their liquid tokens at maximum redemption rate periodically.


Epoch are just like cron or azkaban schedule for code to run.     
There are different types of epoch intervals - Week, Day Epoch, LIQUID_STAKING_DApp_Rewards_EPOCH 12 hours app, REDEMPTION_RATE_QUERY_EPOCH 3 hours app, Rewards withdrawal Epoch.

1)For each contract address determine rewards withdrawal interval. for that epoch number withdraw rewards from pool to contract adddress.

2)If reward amount greater than equal to RewardstoliquidStake (accumulated across contract.LiquidStakeInterval epoch)

3)then create ContractLiquidStakeDepositRecordsForEpoch and push it in Liquid Stake Queue

4)Derive KeyArchLiquidStakeInterval for Archway, 
this determines the frequency when cumulative reward tokens are liquid staked by Archway on Liquidity provider. 

5)Transfer Archway Reward funds from the Archway to Liquidity provider
Iterate over all liquid stake deposit records and do a cumulative reward amount liquid take. 

6)In return, liquidity provider issue liquidity tokens which are distributed in proportion of Dapp reward amount which is getting liquid staked to Dapps

7)After Liquid tokens are obtained from above, Archway will also charge certain proportion of liquidity commission

8)Determine redemption rate query interval and query maximum redemption rate.

9)Archway will redeem liquid tokens in that epoch number for all Dapps

10)Archway will distribute liquid tokens redeemed at threshold rate to all Dapps in ratio of their
stake



Here is brief overview of architecture
++++++++++++++++++++++++++++++++++++++

In Archway code contract metadata is used to store Rewards Address for contract.

Certain additional fields like -
1)enableliquidstaking - to enable liquid staking for contract, 
2)Liquidity tokens address - address where contracts liquid tokens will be stored, 
3)redemption address - redemption tokens distribution address, 
4)minimumrewardstoliquidstake - minimum rewards amount to liquid stake, 
5)liquid stake interval - Liquid Stake Interval for rewards, after rewards aggregation,
6)redemption interval - Redemption Interval for redeeming liquid tokens, 
7)rewards_withdrawal_interval - Rewards Withdrawal Interval for Dapp rewards withdrawal from pool


Description of epoch module to optimise liquid staking on Archway
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                  
Epoch are just like cron or azkaban schedule for code to run.     
There are different types of epoch intervals - Week, Day Epoch, LIQUID_STAKING_DApp_Rewards_EPOCH 12 hours app, REDEMPTION_RATE_QUERY_EPOCH 3 hours app.
Now I am going to describe epoch architecture.
There is prefix key value store dedicated to storing epoch information where key for epoch info records are - epoch identifiers for different types of epoch.
Keeper supports operation such as getting, setting,deleting,iterating all Epoch info objects.
In the begin blocker, each epoch info object is iterated upon and should particular type of epoch start or not is determined by comparing current block time is after epoch start time, start epoch flags are set for different epoch types based on above condition, epoch counter i.e epoch number is increased for each epoch type, next epoch number start time is determined and epoch info is serialised to store.  

There are two hooks available -
AfterEpochEnd and BeforeEpochStart

Following code executes in before epoch start - 

a)
// Liquid_Staking_Module Epoch - Process Liquid staking Deposits

if epochInfo.Identifier == epochstypes.LIQUID_STAKING_DApp_Rewards_EPOCH

For each contract address with liquid staking enabled{

If epochNumber%contract.LiquidStakeInterval == 0 {

If contract.RewardAmount > contract.RewardstoLiquidStake {

//If reward amount greater than equal to RewardstoliquidStake (accumulated across contract.LiquidStakeInterval epoch),

// add full rewards amount, if set to Max
k.CreateContractLiquidStakeDepositRecordsForEpoch(ctx, epochNumber, contractaddress )

then create ContractLiquidStakeDepositRecordsForEpoch and push it in Liquid Stake Queue

b)

Derive KeyArchLiquidStakeInterval for Archway, 
this determines the frequency when cumulative reward tokens are liquid staked by Archway on Liquidity provider.                     

LiquidStakeInterval := k.GetParam(ctx, types.KeyArchLiquidStakeInterval)

if epochNumber%ArchLiquidStakeInterval == 0 {

//Grab all deposit records

depositRecords :=

k.RecordsKeeper.GetALLContractLiquidStakeDepositRecordsForEpoch (ctx)


// Transfer Archway Reward funds from the Archway to Liquidity provider
// Iterate over all liquid stake deposit records and do a cumulative reward amount liquid take.
k.LiquidStake(ctx, epochNumber,ContractLiquidStakeDepositRecords)

In return, liquidity provider issue liquidity tokens which are distributed in proportion of Dapp reward amount which is getting liquid staked to Dapps.
k.DistributeLiquidity(ctx, epochNumber,ContractLiquidStakeDepositRecords)
// After Liquid tokens are obtained from above, Archway will also charge certain proportion of liquidity commission


c)
// REDEMPTION_RATE_QUERY_EPOCH - Process redemption rate query
if epochInfo.Identifier == epochstypes. REDEMPTION_RATE_QUERY_EPOCH {

Determine redemption rate query interval 

RedemptionRateQueryInterval:= k.GetParam(ctx, types.RedemptionRateQueryInterval

if epochNumber%RedemptionRateQueryInterval == 0 {


k. QueryRedemptionRate (ctx, epochNumber)


RedemptionRateThreshold := k.GetParam(ctx, types.RedemptionRateThreshold)


RedemptionIntervalThreshold := k.GetParam(ctx, types.RedemptionIntervalThreshold
if RedemptionRate > RedemptionRateThreshold {
// Process redemption
If timeSinceLatestRedemption > RedeemInterval
//Archway will redeem liquid tokens in that epoch number for all Dapps
k.Reedem(ctx, epochNumber, cumulativeliquidityamount)


//Archway will distribute liquid tokens redeemed at threshold rate to all Dapps in ratio of their
stake
k.DistributeRedeemedToken((ctx, epochNumber, cumulativeliquidityamount)

//Cleanup liquid stake deposit records which have been redeemed from store
}
}
}

d)

// Withdraw rewards - Process rewards withdrawal query
if epochInfo.Identifier == epochstypes. REWARDS_WITHDRAWAL_EPOCH {

For each contract address determine rewards withdrawal interval {
RewardsWithdrawalInterval:= k.GetParam(ctx, types.RewardsWithdrawalInterval)

if epochNumber%RewardsWithdrawalInterval == 0 {
k.DistributeRewards((ctx, epochNumber, cumulativerewards)
}

}
//Currently rewards distribution is not scheduled in Archway and has to be done via separate client transaction


Airdrops additional source of revenue for the Dapp
++++++++++++++++++++++++++++++++++++++++++++++++++++

Dapp participate in core network activities like Liquid staking can claim their airdrop. An Airdrop recipient is given 20% of the airdrop amount which is not in vesting, and then they have to perform the following activities to get the rest:
60% vesting over 3 months by liquid staking
These claimable assets 'expire' if not claimed. Dapps have three months (AirdropDuration) to claim their full airdrop amount. After three months from launch, all unclaimed tokens get sent to the community pool. At initialization, module stores all airdrop users with amounts from genesis inside KVStore. Airdrop users are eligible to claim their vesting or free amount only once in the initial period of 3 months. After the initial period, users can claim tokens monthly.
 

Staking and reinvestment steps:
+++++++++++++++++++++++++++++++++++

Staking occurs every 6 hours and it goes through 3 epochs:

epoch n: New deposit record (DR) which tracks all deposits in a given epoch for a given host zone is created with 0 tokens. LiquidStake is called then and stTokens are minted, but the actual staking of the user’s tokens is addressed in epoch n+2.
epoch n+1: All tokens on DR from epoch n are IBC transferred from provider’s module account to Delegation ICA. Whenever a change to delegation happens all of the rewards are withdrawn (to Withdraw ICA). 
epoch n+2: Tokens on the DR are staked (by weight) across all validators.

Reinvestment executes automatically and the rewards are auto-compounded on every epoch (6h). 90% of the rewards are being sent to Delegation ICA (reinvestment) and 10% to the Fee ICA (the place where liquidity provider charges the fees)

epoch n: Queries Interchain Query (ICQ) to check balances of Withdraw ICA and creates a new record for those tokens.
epoch n+1: Transfers tokens to Delegation ICA from the Withdraw ICA.
epoch n+2: Stakes the tokens.


Moves the Deposit record (DR) marked TRANSFER_QUEUE from previous epochs. Under the hub, it con structs IBC MsgTransfer with 30min timeout. TransferCallback is also created which is been called OnAcknowledgementPacket or OnTimeoutPacket. In the case of nill ack or ack_error DR’s status is set back to TRANSFER_QUEUE otherwise it becomes a candidate for delegation with DELEGATION_QUEUE flag.

Delegates DRs with status DELEGATION_QUEUE. It creates a set of MsgDelegate msgs (delegation to every validator from that host zone whose relative amount is positive). Each validator gets targetAmount=valWeight*depRecordAmount / totalValWeight. Also, DelegateCallback is defined. In the case of the happy ibc path, the zone’s staked balance is increased by a delegated amount to each validator whose delegationAmt is updated and finally DR is removed.

Rewards are automatically sent to the Withdrawal ICA.

WithdrawalBalanceCallback executes ICA SendTx with MsgSend to Delegation ICA (90% reward) and Fee ICA (10% reward). It also adds ReinvestCallback which triggers as previous ones, and in the happy path, it creates a new DR with DELEGATION_QUEUE status (using WITHDRAWAL_ICA source this time, not Archway source) while the sad path is ignored.







